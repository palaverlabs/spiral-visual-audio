<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Visual Audio Groove Codec</title>
<style>
    * {
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #0f0f0f 0%, #1a1a1a 100%);
      color: #fff;
      text-align: center;
      margin: 0;
      padding: 20px;
      min-height: 100vh;
      -webkit-tap-highlight-color: transparent;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    .header {
      margin-bottom: 30px;
    }
    
    .header h1 {
      font-size: 2.5em;
      background: linear-gradient(45deg, #4ecdc4, #44a08d);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin: 0;
    }
    
    .subtitle {
      color: #888;
      font-size: 1.1em;
      margin: 10px 0;
    }
    
    .main-content {
      display: grid;
      grid-template-columns: 1fr 500px;
      gap: 30px;
      align-items: start;
    }
    
    .controls-panel {
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
      padding: 25px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .groove-display {
      width: 500px;
      height: 500px;
      position: relative;
      overflow: hidden;
    }

    .groove-display canvas {
      width: 100%;
      height: 100%;
      display: block;
      border-radius: 50%;
    }
    
    .upload-area {
      border: 2px dashed #4ecdc4;
      border-radius: 12px;
      padding: 30px;
      margin: 20px 0;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .upload-area:hover {
      background: rgba(78, 205, 196, 0.1);
      border-color: #44a08d;
    }
    
    .upload-area.dragover {
      background: rgba(78, 205, 196, 0.2);
      border-color: #4ecdc4;
      transform: scale(1.02);
    }
    
    .btn {
      background: linear-gradient(45deg, #4ecdc4, #44a08d);
      border: none;
      padding: 14px 28px;
      margin: 8px;
      color: white;
      border-radius: 25px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 16px;
      touch-action: manipulation;
    }
    
    .btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(78, 205, 196, 0.4);
    }
    
    .btn:active:not(:disabled) {
      transform: translateY(0);
    }
    
    .btn:disabled {
      background: #666;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    .btn.loading {
      background: #888;
      position: relative;
      overflow: hidden;
    }
    
    .btn.loading::after {
      content: '';
      position: absolute;
      left: -50%;
      top: 0;
      width: 50%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      animation: loading 1.5s infinite;
    }
    
    @keyframes loading {
      0% { left: -50%; }
      100% { left: 100%; }
    }
    
    .status {
      margin: 15px 0;
      padding: 10px;
      border-radius: 8px;
      font-weight: 500;
    }
    
    .status.success {
      background: rgba(78, 205, 196, 0.2);
      color: #4ecdc4;
      border: 1px solid rgba(78, 205, 196, 0.3);
    }
    
    .status.error {
      background: rgba(255, 68, 68, 0.2);
      color: #ff4444;
      border: 1px solid rgba(255, 68, 68, 0.3);
    }
    
    .status.info {
      background: rgba(255, 193, 7, 0.2);
      color: #ffc107;
      border: 1px solid rgba(255, 193, 7, 0.3);
    }
    
    .controls-section {
      margin: 20px 0;
      padding: 15px;
      background: rgba(255,255,255,0.05);
      border-radius: 10px;
      border-left: 4px solid #4ecdc4;
    }
    
    .controls-section h3 {
      margin: 0 0 15px 0;
      color: #4ecdc4;
      font-size: 1.1em;
    }
    
    .control-group {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin: 10px 0;
    }
    
    .control-group label {
      color: #ddd;
      font-weight: 500;
      white-space: nowrap;
    }
    
    .control-group input[type="range"] {
      flex: 1;
      min-width: 80px;
      max-width: 200px;
      margin: 0 10px;
      height: 28px;
      cursor: pointer;
    }
    
    .control-group .value {
      color: #4ecdc4;
      font-weight: 600;
      min-width: 40px;
      text-align: right;
    }
    
    .playback-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin: 20px 0;
    }
    
    .time-display {
      font-family: 'Courier New', monospace;
      font-size: 1.2em;
      color: #4ecdc4;
      margin: 15px 0;
      padding: 10px;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
    }
    
    .debug {
      background: rgba(0,0,0,0.8);
      color: #4ecdc4;
      padding: 15px;
      margin-top: 20px;
      border-radius: 10px;
      text-align: left;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #333;
    }
    
    
    input[type="file"] {
      display: none;
    }
    
    .audio-info {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin: 15px 0;
      font-size: 14px;
    }
    
    .audio-info .info-item {
      background: rgba(0,0,0,0.3);
      padding: 8px;
      border-radius: 6px;
      text-align: center;
    }
    
    .audio-info .info-label {
      color: #888;
      font-size: 12px;
      margin-bottom: 4px;
    }
    
    .audio-info .info-value {
      color: #4ecdc4;
      font-weight: 600;
    }

    @media (max-width: 1024px) {
      .main-content {
        grid-template-columns: 1fr;
        gap: 20px;
      }
      
      .groove-display {
        width: min(400px, calc(100vw - 50px));
        height: min(400px, calc(100vw - 50px));
        margin: 0 auto;
      }
    }

    @media (max-width: 600px) {
      body {
        padding: 10px;
      }

      .header {
        margin-bottom: 15px;
      }

      .header h1 {
        font-size: 1.6em;
      }

      .subtitle {
        font-size: 0.9em;
        margin: 5px 0;
      }

      .main-content {
        grid-template-columns: 1fr;
        gap: 15px;
      }

      .groove-display {
        width: min(320px, calc(100vw - 30px));
        height: min(320px, calc(100vw - 30px));
        margin: 0 auto;
        order: -1;
      }

      .controls-panel {
        padding: 15px;
        border-radius: 12px;
      }

      .controls-section {
        margin: 12px 0;
        padding: 12px;
      }

      .controls-section h3 {
        margin: 0 0 10px 0;
        font-size: 1em;
      }

      .upload-area {
        padding: 20px 15px;
        margin: 12px 0;
      }

      .btn {
        padding: 14px 20px;
        font-size: 15px;
        margin: 6px 4px;
        min-height: 48px;
      }

      .control-group {
        margin: 8px 0;
      }

      .control-group label {
        font-size: 14px;
      }

      .control-group input[type="range"] {
        margin: 0 8px;
      }

      .debug {
        font-size: 11px;
        padding: 10px;
        max-height: 120px;
      }

      .time-display {
        font-size: 1em;
        padding: 8px;
        margin: 10px 0;
      }
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 30px;
    }
    .header-left { text-align: left; }

    .btn-wallet {
      padding: 10px 20px;
      font-size: 0.9em;
      white-space: nowrap;
    }
    .btn-wallet.connected {
      background: linear-gradient(45deg, #44a08d, #2d6a5a);
    }
    .wallet-address {
      font-size: 0.75em;
      opacity: 0.8;
      display: block;
      margin-top: 2px;
    }
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <div class="header-left">
      <h1>Visual Audio Groove Codec</h1>
      <div class="subtitle">Transform audio into visual grooves &bull; Load & play existing grooves</div>
    </div>
    <div class="wallet-area">
      <button class="btn btn-wallet" id="walletBtn">Connect Wallet</button>
    </div>
  </div>
  
  <div class="main-content">
    <div class="controls-panel">
      <div class="controls-section">
        <h3>Audio Input</h3>
        <div class="upload-area" id="uploadArea">
          <div style="font-size: 2em; margin-bottom: 10px;">&#127925;</div>
          <div style="font-weight: 600; margin-bottom: 5px;">Drop audio file here</div>
          <div style="color: #888; font-size: 14px;">or click to browse</div>
          <input type="file" id="audioFile" accept="audio/*">
        </div>
        
        <div class="upload-area" id="svgUploadArea" style="margin-top: 15px; border-color: #da70d6; background: rgba(218, 112, 214, 0.05);">
          <div style="font-size: 2em; margin-bottom: 10px;">&#127744;</div>
          <div style="font-weight: 600; margin-bottom: 5px; color: #da70d6;">Drop visual groove SVG here</div>
          <div style="color: #888; font-size: 14px;">or click to load existing groove</div>
          <input type="file" id="svgFile" accept=".svg,image/svg+xml">
        </div>
        
        <div class="status info" id="audioStatus">
          No audio loaded
        </div>
        
        <div class="audio-info" id="audioInfo" style="display: none;">
          <div class="info-item">
            <div class="info-label">Duration</div>
            <div class="info-value" id="infoDuration">--</div>
          </div>
          <div class="info-item">
            <div class="info-label">Sample Rate</div>
            <div class="info-value" id="infoSampleRate">--</div>
          </div>
          <div class="info-item">
            <div class="info-label">Channels</div>
            <div class="info-value" id="infoChannels">--</div>
          </div>
          <div class="info-item">
            <div class="info-label">File Size</div>
            <div class="info-value" id="infoSize">--</div>
          </div>
        </div>
      </div>
      
      <div class="controls-section">
        <h3>Groove Settings</h3>
        <div class="control-group">
          <label>Quality:</label>
          <input type="range" id="qualitySlider" min="1" max="5" value="3" step="1">
          <span class="value" id="qualityValue">3</span>
        </div>
        <div class="control-group">
          <label>Spiral Turns:</label>
          <input type="range" id="turnsSlider" min="3" max="80" value="30" step="1">
          <span class="value" id="turnsValue">30</span>
        </div>
        <div class="control-group">
          <label>Groove Sensitivity:</label>
          <input type="range" id="sensitivitySlider" min="1" max="10" value="5" step="1">
          <span class="value" id="sensitivityValue">5</span>
        </div>
      </div>
      
      <div class="controls-section">
        <h3>Actions</h3>
        <button class="btn" id="generateGroove" disabled>Generate Visual Groove</button>
        <button class="btn" id="downloadSVG" disabled>Download SVG</button>
        <button class="btn" id="downloadAudio" disabled>Export Audio</button>
        
        <div class="playback-controls">
          <button class="btn" id="playBtn" disabled>Play Groove</button>
          <button class="btn" id="pauseBtn" disabled style="display: none;">Pause</button>
        </div>
        
        <div class="control-group">
          <label>Playback Speed:</label>
          <input type="range" id="speedSlider" min="0.25" max="2" value="1" step="0.25">
          <span class="value" id="speedValue">1.0x</span>
        </div>
      </div>
      
      <div class="time-display">
        <span id="currentTime">00:00</span> / <span id="totalTime">00:00</span>
      </div>
    </div>
    
    <div class="groove-display" id="grooveDisplay">
      <canvas id="grooveCanvas" width="1000" height="1000"></canvas>
    </div>
  </div>
  
  <div class="debug" id="debugLog">
    Visual Audio Groove Codec ready<br>
    &rarr; Upload audio to create new visual groove<br>
    &rarr; Or load existing .svg groove file for playback
  </div>
</div>

<script>
const TAU = Math.PI * 2;

function clamp(x, lo, hi) { return Math.min(hi, Math.max(lo, x)); }
function archBase(t, Rout, Rin) { return Rout + (Rin - Rout) * t; }

const MU = 255;
function muLawCompress(x) {
  const sign = x < 0 ? -1 : 1;
  return sign * Math.log(1 + MU * Math.abs(x)) / Math.log(1 + MU);
}
function muLawExpand(y) {
  const sign = y < 0 ? -1 : 1;
  return sign * ((1 + MU) ** Math.abs(y) - 1) / MU;
}

function antiAliasFilter(samples, decimationFactor) {
  if (decimationFactor <= 1) return samples;
  const kernelRadius = Math.min(Math.ceil(decimationFactor * 2), 64);
  const kernelSize = kernelRadius * 2 + 1;
  const kernel = new Float32Array(kernelSize);
  const cutoff = 0.5 / decimationFactor;
  let sum = 0;
  for (let i = 0; i < kernelSize; i++) {
    const n = i - kernelRadius;
    if (n === 0) {
      kernel[i] = cutoff;
    } else {
      kernel[i] = Math.sin(Math.PI * cutoff * n) / (Math.PI * n);
    }
    const w = 0.42 - 0.5 * Math.cos(TAU * i / (kernelSize - 1)) + 0.08 * Math.cos(2 * TAU * i / (kernelSize - 1));
    kernel[i] *= w;
    sum += kernel[i];
  }
  for (let i = 0; i < kernelSize; i++) kernel[i] /= sum;

  const out = new Float32Array(samples.length);
  for (let i = 0; i < samples.length; i++) {
    let acc = 0;
    for (let j = 0; j < kernelSize; j++) {
      const idx = i + j - kernelRadius;
      if (idx >= 0 && idx < samples.length) {
        acc += samples[idx] * kernel[j];
      }
    }
    out[i] = acc;
  }
  return out;
}

const PREEMPH_COEFF = 0.97;
function preEmphasis(samples) {
  const out = new Float32Array(samples.length);
  out[0] = samples[0];
  for (let i = 1; i < samples.length; i++) {
    out[i] = samples[i] - PREEMPH_COEFF * samples[i - 1];
  }
  return out;
}
function deEmphasis(samples) {
  const out = new Float32Array(samples.length);
  out[0] = samples[0];
  for (let i = 1; i < samples.length; i++) {
    out[i] = samples[i] + PREEMPH_COEFF * out[i - 1];
  }
  return out;
}

function cubicInterpolate(y0, y1, y2, y3, t) {
  const a = -0.5 * y0 + 1.5 * y1 - 1.5 * y2 + 0.5 * y3;
  const b = y0 - 2.5 * y1 + 2 * y2 - 0.5 * y3;
  const c = -0.5 * y0 + 0.5 * y2;
  const d = y1;
  return a * t * t * t + b * t * t + c * t + d;
}

class GrooveCodec {
  constructor() {
    this.originalAudio = null;
    this.decodedAudio = null;
    this.sampleRate = 44100;
    this.duration = 0;
    this.grooveSVG = null;
    this.isPlaying = false;
    this.playbackTime = 0;
    this.animationId = null;
    this.audioSource = null;

    this.Rout = 220;
    this.Rin = 40;
    this.cx = 260;
    this.cy = 260;
    this.spiralTurns = 30;
    this.groovePoints = null;
    this.grooveImage = null;
    this.discRotation = 0;
    this.stylusProgress = 0;

    this.initializeUI();
    this.drawEmptyDisc();
  }

  initializeUI() {
    const uploadArea = document.getElementById('uploadArea');
    const audioFile = document.getElementById('audioFile');

    uploadArea.addEventListener('click', () => audioFile.click());
    uploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadArea.classList.add('dragover');
    });
    uploadArea.addEventListener('dragleave', () => {
      uploadArea.classList.remove('dragover');
    });
    uploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadArea.classList.remove('dragover');
      const file = e.dataTransfer.files[0];
      if (file && file.type.startsWith('audio/')) {
        this.loadAudioFile(file);
      } else if (file && (file.type === 'image/svg+xml' || file.name.endsWith('.svg'))) {
        this.loadGrooveFile(file);
      } else {
        this.debug('Please drop an audio file or SVG groove file');
        this.setStatus('Please drop an audio file or SVG groove file', 'error');
      }
    });

    audioFile.addEventListener('change', (e) => {
      if (e.target.files[0]) this.loadAudioFile(e.target.files[0]);
    });

    const svgUploadArea = document.getElementById('svgUploadArea');
    const svgFile = document.getElementById('svgFile');

    svgUploadArea.addEventListener('click', () => svgFile.click());
    svgUploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      svgUploadArea.classList.add('dragover');
    });
    svgUploadArea.addEventListener('dragleave', () => {
      svgUploadArea.classList.remove('dragover');
    });
    svgUploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
      svgUploadArea.classList.remove('dragover');
      const file = e.dataTransfer.files[0];
      if (file && (file.type === 'image/svg+xml' || file.name.endsWith('.svg'))) {
        this.loadGrooveFile(file);
      } else if (file && file.type.startsWith('audio/')) {
        this.loadAudioFile(file);
      } else {
        this.debug('Please drop an SVG groove file or audio file');
        this.setStatus('Please drop an SVG groove file or audio file', 'error');
      }
    });

    svgFile.addEventListener('change', (e) => {
      if (e.target.files[0]) this.loadGrooveFile(e.target.files[0]);
    });

    document.getElementById('generateGroove').addEventListener('click', () => this.generateGroove());
    document.getElementById('playBtn').addEventListener('click', () => this.startPlayback());
    document.getElementById('pauseBtn').addEventListener('click', () => this.stopPlayback());
    document.getElementById('downloadSVG').addEventListener('click', () => this.downloadSVG());
    document.getElementById('downloadAudio').addEventListener('click', () => this.downloadAudio());

    ['quality', 'turns', 'sensitivity', 'speed'].forEach(param => {
      const slider = document.getElementById(`${param}Slider`);
      const value = document.getElementById(`${param}Value`);
      slider.addEventListener('input', (e) => {
        value.textContent = param === 'speed' ? `${e.target.value}x` : e.target.value;
      });
    });

    this.debug('Visual Audio Groove Codec initialized');
  }

  async loadAudioFile(file) {
    this.debug(`Loading audio file: ${file.name}`);
    this.setStatus('Loading audio file...', 'info');

    try {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const arrayBuffer = await file.arrayBuffer();
      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

      this.originalAudio = audioBuffer.getChannelData(0);
      this.sampleRate = audioBuffer.sampleRate;
      this.duration = audioBuffer.duration;
      this.decodedAudio = null;

      this.setStatus(`Audio loaded: ${file.name}`, 'success');
      this.updateAudioInfo(file, audioBuffer);
      document.getElementById('generateGroove').disabled = false;

      this.debug(`Audio loaded: ${this.originalAudio.length} samples, ${this.sampleRate}Hz, ${this.duration.toFixed(2)}s`);
    } catch (error) {
      this.debug(`Failed to load audio: ${error.message}`);
      this.setStatus('Failed to load audio file', 'error');
    }
  }

  async loadGrooveFile(file) {
    this.debug(`Loading visual groove file: ${file.name}`);
    this.setStatus('Loading visual groove...', 'info');

    try {
      const svgText = await file.text();
      const result = this.decodeFromSVG(svgText);

      this.grooveSVG = svgText;
      this.decodedAudio = result.samples;
      this.sampleRate = result.sampleRate;
      this.duration = result.samples.length / result.sampleRate;
      this.spiralTurns = result.turns;
      this.Rout = result.Rout;
      this.Rin = result.Rin;
      this.cx = result.cx;
      this.cy = result.cy;
      this.originalAudio = null;
      this.groovePoints = result.groovePoints;

      this.setStatus(`Visual groove loaded: ${file.name}`, 'success');
      this.updateGrooveInfo(file, result);
      this.renderGroove();
      this.enablePlaybackControls();

      const genBtn = document.getElementById('generateGroove');
      genBtn.textContent = 'Groove Loaded (Generate New)';
      genBtn.disabled = false;

      this.debug(`Groove loaded: ${result.vertices} vertices, ${result.turns.toFixed(1)} turns, ${this.duration.toFixed(2)}s`);
      this.debug('Ready for playback from visual groove!');
    } catch (error) {
      this.debug(`Failed to load groove: ${error.message}`);
      this.setStatus('Failed to load visual groove file', 'error');
      console.error('Groove loading error:', error);
    }
  }

  encodeToSVG(samples, opts = {}) {
    const originalSr = opts.sr || this.sampleRate;
    const quality = opts.quality || 3;
    const turns = opts.turns || 6;
    const sensitivity = opts.sensitivity || 5;
    const Rout = this.Rout;
    const Rin = this.Rin;
    const cx = this.cx;
    const cy = this.cy;

    const totalSamples = samples.length;
    const maxPoints = [200000, 500000, 1000000, 1500000, 2000000][quality - 1];
    const N = Math.min(totalSamples, maxPoints);
    const decimationFactor = totalSamples / N;

    const duration = totalSamples / originalSr;
    const effectiveSr = Math.round(N / duration);

    const filtered = decimationFactor > 1 ? antiAliasFilter(samples, decimationFactor) : samples;
    const emphasized = preEmphasis(filtered);

    let emphPeak = 0;
    for (let i = 0; i < emphasized.length; i++) {
      const a = Math.abs(emphasized[i]);
      if (a > emphPeak) emphPeak = a;
    }
    if (emphPeak > 1.0) {
      const scale = 1.0 / emphPeak;
      for (let i = 0; i < emphasized.length; i++) emphasized[i] *= scale;
    }

    const downsampled = new Float32Array(N);
    for (let i = 0; i < N; i++) {
      const srcIdx = Math.min(Math.floor(i * decimationFactor), totalSamples - 1);
      downsampled[i] = muLawCompress(clamp(emphasized[srcIdx], -1, 1));
    }

    const drPerTurn = (Rout - Rin) / Math.max(1, turns);
    const kMax = 0.45 * drPerTurn;
    const k = Math.min(sensitivity, kMax);

    const ditherScale = 0.0005;
    const pts = new Array(N);
    const canvasPoints = new Float32Array(N * 2);
    for (let i = 0; i < N; i++) {
      const t = i / (N - 1);
      const theta = t * turns * TAU;
      const rBase = archBase(t, Rout, Rin);
      const r = rBase + k * clamp(downsampled[i], -1, 1);
      const x = cx + r * Math.cos(theta);
      const y = cy + r * Math.sin(theta);
      const dx = (Math.random() + Math.random() - 1) * ditherScale;
      const dy = (Math.random() + Math.random() - 1) * ditherScale;
      pts[i] = `${(x + dx).toFixed(3)},${(y + dy).toFixed(3)}`;
      canvasPoints[i * 2] = x + dx;
      canvasPoints[i * 2 + 1] = y + dy;
    }
    this.groovePoints = canvasPoints;

    const outerR = Rout + 8;
    const innerR = Math.max(12, Rin - 8);

    const ptsPerTurn = Math.round(N / turns);
    const sizeMB = (N * 17 / 1024 / 1024).toFixed(1);
    const pipeline = decimationFactor > 1 ? `pre-emph → anti-alias → ${decimationFactor.toFixed(1)}x decimate → mu-law → dither` : 'pre-emph → mu-law → dither';
    this.debug(`Encoded ${totalSamples} samples → ${N} vertices [${pipeline}] (~${ptsPerTurn} pts/turn, ${turns} turns, k=${k.toFixed(4)}, sr=${effectiveSr}Hz, ~${sizeMB} MB)`);

    return `<svg xmlns="http://www.w3.org/2000/svg" width="520" height="520" viewBox="0 0 520 520" role="img" aria-label="Geometry-only spiral record">
  <defs>
    <radialGradient id="discGrad" r="60%">
      <stop offset="0%" stop-color="#0e1217"/>
      <stop offset="100%" stop-color="#0b0f14"/>
    </radialGradient>
  </defs>
  <circle cx="${cx}" cy="${cy}" r="${outerR}" fill="url(#discGrad)" stroke="#233242" stroke-width="2"/>
  <circle cx="${cx}" cy="${cy}" r="${innerR}" fill="#0a0d11" stroke="#22303b" stroke-width="2"/>
  <polyline id="audioGroove" fill="none" stroke="#5ad8cf" stroke-width="0.8" stroke-linecap="round" points="${pts.join(' ')}" />
  <desc>Geometry-only spiral audio. sr=${effectiveSr}; Rout=${Rout}; Rin=${Rin}; turns=${turns}; k=${k.toFixed(6)}; originalLength=${N}; mulaw=1; preemph=1.</desc>
</svg>`;
  }

  decodeFromSVG(svgString) {
    const doc = new DOMParser().parseFromString(svgString, 'image/svg+xml');
    const poly = doc.querySelector('polyline#audioGroove');
    if (!poly) throw new Error('No groove polyline found in SVG');

    let cx = this.cx, cy = this.cy;
    const firstCircle = doc.querySelector('circle');
    if (firstCircle) {
      cx = parseFloat(firstCircle.getAttribute('cx')) || this.cx;
      cy = parseFloat(firstCircle.getAttribute('cy')) || this.cy;
    }

    const pointsStr = (poly.getAttribute('points') || '').trim();
    if (!pointsStr) throw new Error('Empty points attribute in polyline');
    const rawParts = pointsStr.split(/\s+/);
    const coords = new Array(rawParts.length);
    const groovePoints = new Float32Array(rawParts.length * 2);
    for (let i = 0; i < rawParts.length; i++) {
      const [x, y] = rawParts[i].split(',').map(Number);
      coords[i] = { x, y };
      groovePoints[i * 2] = x;
      groovePoints[i * 2 + 1] = y;
    }
    const N = coords.length;

    const circles = doc.querySelectorAll('circle');
    let Rout = this.Rout, Rin = this.Rin;
    if (circles.length >= 2) {
      const rOutCircle = parseFloat(circles[0].getAttribute('r')) || 228;
      const rInCircle = parseFloat(circles[1].getAttribute('r')) || 32;
      Rout = Math.max(30, rOutCircle - 8);
      Rin = Math.max(12, rInCircle + 8);
    }

    let totalAngle = 0;
    let prevA = Math.atan2(coords[0].y - cy, coords[0].x - cx);
    for (let i = 1; i < N; i++) {
      const a = Math.atan2(coords[i].y - cy, coords[i].x - cx);
      let d = a - prevA;
      while (d > Math.PI) d -= TAU;
      while (d < -Math.PI) d += TAU;
      totalAngle += d;
      prevA = a;
    }
    const turns = Math.abs(totalAngle) / TAU;

    let sr = 22050;
    let originalLength = 0;
    let storedK = 0;
    let useMulaw = false;
    let usePreemph = false;
    const descEl = doc.querySelector('desc');
    if (descEl) {
      const descText = descEl.textContent || '';
      const srMatch = descText.match(/sr=(\d+)/);
      if (srMatch) sr = parseInt(srMatch[1]);
      const olMatch = descText.match(/originalLength=(\d+)/);
      if (olMatch) originalLength = parseInt(olMatch[1]);
      const kMatch = descText.match(/k=([\d.]+)/);
      if (kMatch) storedK = parseFloat(kMatch[1]);
      useMulaw = /mulaw=1/.test(descText);
      usePreemph = /preemph=1/.test(descText);
    }

    const k = storedK > 0 ? storedK : (function estimateK() {
      const sampleWindow = Math.min(2000, Math.floor(N / 10));
      let accum = 0, count = 0;
      for (let i = 0; i < sampleWindow; i++) {
        const t = i / (N - 1);
        const rBase = archBase(t, Rout, Rin);
        const dx = coords[i].x - cx, dy = coords[i].y - cy;
        const r = Math.hypot(dx, dy);
        accum += Math.abs(r - rBase);
        count++;
      }
      const mad = (accum / Math.max(1, count)) || 1.0;
      return Math.max(0.5, mad / 0.25);
    })();

    const rawDecoded = new Float32Array(N);
    for (let i = 0; i < N; i++) {
      const dx = coords[i].x - cx, dy = coords[i].y - cy;
      const r = Math.hypot(dx, dy);
      const t = i / (N - 1);
      const rBase = archBase(t, Rout, Rin);
      const raw = clamp((r - rBase) / k, -1, 1);
      rawDecoded[i] = useMulaw ? muLawExpand(raw) : raw;
    }

    let decoded = usePreemph ? deEmphasis(rawDecoded) : rawDecoded;

    const rcRadius = 6;
    const rcSize = rcRadius * 2 + 1;
    const rcKernel = new Float32Array(rcSize);
    let rcSum = 0;
    for (let i = 0; i < rcSize; i++) {
      rcKernel[i] = Math.exp(-0.5 * ((i - rcRadius) / (rcRadius * 0.35)) ** 2);
      rcSum += rcKernel[i];
    }
    for (let i = 0; i < rcSize; i++) rcKernel[i] /= rcSum;
    const smoothed = new Float32Array(N);
    for (let i = 0; i < N; i++) {
      let acc = 0;
      for (let j = 0; j < rcSize; j++) {
        const idx = Math.min(N - 1, Math.max(0, i + j - rcRadius));
        acc += decoded[idx] * rcKernel[j];
      }
      smoothed[i] = acc;
    }
    decoded = smoothed;

    let out = decoded;
    if (originalLength > 0 && originalLength !== N) {
      out = new Float32Array(originalLength);
      for (let i = 0; i < originalLength; i++) {
        const srcIdx = (i / originalLength) * (N - 1);
        const idx = Math.floor(srcIdx);
        const frac = srcIdx - idx;
        const i0 = Math.max(0, idx - 1);
        const i1 = idx;
        const i2 = Math.min(N - 1, idx + 1);
        const i3 = Math.min(N - 1, idx + 2);
        out[i] = cubicInterpolate(decoded[i0], decoded[i1], decoded[i2], decoded[i3], frac);
      }
    }

    let dcSum = 0;
    for (let i = 0; i < out.length; i++) dcSum += out[i];
    const dcOffset = dcSum / out.length;
    if (Math.abs(dcOffset) > 0.001) {
      for (let i = 0; i < out.length; i++) out[i] -= dcOffset;
    }

    let peak = 0;
    for (let i = 0; i < out.length; i++) {
      const a = Math.abs(out[i]);
      if (a > peak) peak = a;
    }
    if (peak > 0.001 && peak < 0.99) {
      const gain = 1.0 / peak;
      for (let i = 0; i < out.length; i++) out[i] *= gain;
    }

    const fadeLen = Math.min(256, Math.floor(out.length * 0.005));
    for (let i = 0; i < fadeLen; i++) {
      const g = i / fadeLen;
      out[i] *= g;
      out[out.length - 1 - i] *= g;
    }

    return { samples: out, sampleRate: sr, turns, vertices: N, Rout, Rin, cx, cy, k, groovePoints };
  }

  generateGroove() {
    if (!this.originalAudio) {
      this.debug('No audio data to encode');
      this.setStatus('Please load an audio file first', 'error');
      return;
    }

    const btn = document.getElementById('generateGroove');
    btn.classList.add('loading');
    btn.textContent = 'Encoding Audio...';
    btn.disabled = true;

    const sampleCount = this.originalAudio.length;
    this.debug(`Starting encoding: ${sampleCount} samples...`);
    this.setStatus(`Encoding ${sampleCount} samples...`, 'info');

    setTimeout(() => {
      try {
        const quality = parseInt(document.getElementById('qualitySlider').value);
        const turns = parseInt(document.getElementById('turnsSlider').value);
        const sensitivity = parseInt(document.getElementById('sensitivitySlider').value);

        this.spiralTurns = turns;
        this.grooveSVG = this.encodeToSVG(this.originalAudio, {
          sr: this.sampleRate,
          quality,
          turns,
          sensitivity
        });

        this.renderGroove();
        this.enablePlaybackControls();

        const sizeBytes = this.grooveSVG.length;
        const sizeLabel = sizeBytes > 1024 * 1024 ? `${(sizeBytes / 1024 / 1024).toFixed(1)} MB` : `${(sizeBytes / 1024).toFixed(0)} KB`;
        this.debug(`Groove generated: ${sizeLabel} SVG`);
        this.setStatus(`Groove generated (${sizeLabel}). Ready for playback!`, 'success');
      } catch (error) {
        this.debug(`Groove generation failed: ${error.message}`);
        this.setStatus('Failed to generate groove', 'error');
      }

      btn.classList.remove('loading');
      btn.textContent = 'Generate Visual Groove';
      btn.disabled = false;
    }, 100);
  }

  drawEmptyDisc() {
    const canvas = document.getElementById('grooveCanvas');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scale = W / 520;
    const cx = this.cx * scale, cy = this.cy * scale;
    const Rout = (this.Rout + 8) * scale;
    const Rin = Math.max(12, this.Rin - 8) * scale;
    const labelR = 45 * scale;

    ctx.clearRect(0, 0, W, H);

    const discGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, Rout);
    discGrad.addColorStop(0, '#1a1e25');
    discGrad.addColorStop(0.85, '#0e1217');
    discGrad.addColorStop(1, '#0b0f14');
    ctx.beginPath();
    ctx.arc(cx, cy, Rout, 0, TAU);
    ctx.fillStyle = discGrad;
    ctx.fill();
    ctx.strokeStyle = '#233242';
    ctx.lineWidth = 2 * scale;
    ctx.stroke();

    for (let i = 0; i < 8; i++) {
      const r = Rin + (Rout - Rin) * (i / 8);
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, TAU);
      ctx.strokeStyle = 'rgba(90, 216, 207, 0.04)';
      ctx.lineWidth = 0.5 * scale;
      ctx.stroke();
    }

    const labelGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, labelR);
    labelGrad.addColorStop(0, '#2a1a3a');
    labelGrad.addColorStop(1, '#1a0e2a');
    ctx.beginPath();
    ctx.arc(cx, cy, labelR, 0, TAU);
    ctx.fillStyle = labelGrad;
    ctx.fill();
    ctx.strokeStyle = '#4a3060';
    ctx.lineWidth = 1.5 * scale;
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(cx, cy, 4 * scale, 0, TAU);
    ctx.fillStyle = '#333';
    ctx.fill();

    ctx.font = `${11 * scale}px 'Segoe UI', sans-serif`;
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.textAlign = 'center';
    ctx.fillText('DROP AUDIO', cx, cy - 4 * scale);
    ctx.font = `${8 * scale}px 'Segoe UI', sans-serif`;
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.fillText('TO GENERATE GROOVE', cx, cy + 8 * scale);
  }

  renderGroove() {
    if (!this.groovePoints) return;
    this.discRotation = 0;
    this.preRenderGroove();
    this.drawDiscWithGroove(0, -1);
    this.debug('Visual groove rendered on canvas');
  }

  preRenderGroove() {
    const canvas = document.getElementById('grooveCanvas');
    const W = canvas.width, H = canvas.height;
    const scale = W / 520;
    const points = this.groovePoints;
    const N = points.length / 2;
    if (N === 0) return;

    const offscreen = document.createElement('canvas');
    offscreen.width = W;
    offscreen.height = H;
    const ctx = offscreen.getContext('2d');

    const step = Math.max(1, Math.floor(N / 200000));

    ctx.lineWidth = 0.6 * scale;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.strokeStyle = 'rgba(90, 216, 207, 0.55)';
    ctx.beginPath();
    ctx.moveTo(points[0] * scale, points[1] * scale);
    for (let i = step; i < N; i += step) {
      ctx.lineTo(points[i * 2] * scale, points[i * 2 + 1] * scale);
    }
    ctx.stroke();

    ctx.shadowColor = '#5ad8cf';
    ctx.shadowBlur = 3 * scale;
    ctx.strokeStyle = 'rgba(90, 216, 207, 0.12)';
    ctx.beginPath();
    ctx.moveTo(points[0] * scale, points[1] * scale);
    for (let i = step; i < N; i += step) {
      ctx.lineTo(points[i * 2] * scale, points[i * 2 + 1] * scale);
    }
    ctx.stroke();
    ctx.shadowBlur = 0;

    this.grooveImage = offscreen;
  }

  drawDiscWithGroove(rotation, stylusProgress) {
    const canvas = document.getElementById('grooveCanvas');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const scale = W / 520;
    const cx = this.cx * scale, cy = this.cy * scale;
    const Rout = (this.Rout + 8) * scale;
    const Rin = Math.max(12, this.Rin - 8) * scale;
    const labelR = 45 * scale;

    ctx.clearRect(0, 0, W, H);

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(rotation);
    ctx.translate(-cx, -cy);

    const discGrad = ctx.createRadialGradient(cx, cy, Rin, cx, cy, Rout);
    discGrad.addColorStop(0, '#151920');
    discGrad.addColorStop(0.5, '#0e1217');
    discGrad.addColorStop(1, '#0b0f14');
    ctx.beginPath();
    ctx.arc(cx, cy, Rout, 0, TAU);
    ctx.fillStyle = discGrad;
    ctx.fill();
    ctx.strokeStyle = '#233242';
    ctx.lineWidth = 2 * scale;
    ctx.stroke();

    if (this.grooveImage) {
      ctx.drawImage(this.grooveImage, 0, 0);
    }

    const labelGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, labelR);
    labelGrad.addColorStop(0, '#2a1a3a');
    labelGrad.addColorStop(0.7, '#1e1030');
    labelGrad.addColorStop(1, '#150a22');
    ctx.beginPath();
    ctx.arc(cx, cy, labelR, 0, TAU);
    ctx.fillStyle = labelGrad;
    ctx.fill();
    ctx.strokeStyle = '#4a3060';
    ctx.lineWidth = 1.5 * scale;
    ctx.stroke();

    ctx.font = `bold ${9 * scale}px 'Segoe UI', sans-serif`;
    ctx.fillStyle = 'rgba(200,170,255,0.4)';
    ctx.textAlign = 'center';
    ctx.fillText('VAGC', cx, cy + 3 * scale);

    ctx.beginPath();
    ctx.arc(cx, cy, 4 * scale, 0, TAU);
    ctx.fillStyle = '#222';
    ctx.fill();
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 1 * scale;
    ctx.stroke();

    ctx.restore();

    const sheenGrad = ctx.createRadialGradient(cx - Rout * 0.25, cy - Rout * 0.25, 0, cx - Rout * 0.25, cy - Rout * 0.25, Rout * 0.9);
    sheenGrad.addColorStop(0, 'rgba(255,255,255,0.04)');
    sheenGrad.addColorStop(0.5, 'rgba(255,255,255,0.01)');
    sheenGrad.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.save();
    ctx.beginPath();
    ctx.arc(cx, cy, Rout - 2 * scale, 0, TAU);
    ctx.clip();
    ctx.fillStyle = sheenGrad;
    ctx.fillRect(0, 0, W, H);
    ctx.restore();

    if (stylusProgress >= 0 && stylusProgress <= 1) {
      const ROut = this.Rout;
      const RIn = this.Rin;
      const t = stylusProgress;
      const fixedAngle = -Math.PI * 0.25;
      const r = (ROut - t * (ROut - RIn)) * scale;
      const sx = cx + r * Math.cos(fixedAngle);
      const sy = cy + r * Math.sin(fixedAngle);

      ctx.save();

      ctx.shadowColor = '#ff2200';
      ctx.shadowBlur = 35 * scale;
      ctx.beginPath();
      ctx.arc(sx, sy, 6 * scale, 0, TAU);
      ctx.fillStyle = 'rgba(255, 30, 0, 0.4)';
      ctx.fill();

      ctx.shadowBlur = 20 * scale;
      ctx.beginPath();
      ctx.arc(sx, sy, 4 * scale, 0, TAU);
      ctx.fillStyle = 'rgba(255, 60, 20, 0.7)';
      ctx.fill();

      ctx.shadowColor = '#ff6644';
      ctx.shadowBlur = 12 * scale;
      ctx.beginPath();
      ctx.arc(sx, sy, 2.5 * scale, 0, TAU);
      ctx.fillStyle = '#ff4422';
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.beginPath();
      ctx.arc(sx, sy, 1.2 * scale, 0, TAU);
      ctx.fillStyle = '#fff';
      ctx.fill();

      const beamLen = 25 * scale;
      const beamGrad = ctx.createLinearGradient(sx, sy, sx, sy - beamLen);
      beamGrad.addColorStop(0, 'rgba(255, 50, 20, 0.5)');
      beamGrad.addColorStop(0.3, 'rgba(255, 50, 20, 0.15)');
      beamGrad.addColorStop(1, 'rgba(255, 50, 20, 0)');
      ctx.fillStyle = beamGrad;
      ctx.beginPath();
      ctx.moveTo(sx - 2.5 * scale, sy);
      ctx.lineTo(sx - 0.8 * scale, sy - beamLen);
      ctx.lineTo(sx + 0.8 * scale, sy - beamLen);
      ctx.lineTo(sx + 2.5 * scale, sy);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }
  }

  enablePlaybackControls() {
    document.getElementById('totalTime').textContent = this.formatTime(this.duration);
    ['playBtn', 'downloadSVG', 'downloadAudio'].forEach(id => {
      document.getElementById(id).disabled = false;
    });
  }

  getPlaybackAudio() {
    if (this.decodedAudio) return { samples: this.decodedAudio, sampleRate: this.sampleRate };
    if (!this.grooveSVG) return null;

    const result = this.decodeFromSVG(this.grooveSVG);
    return { samples: result.samples, sampleRate: result.sampleRate };
  }

  startPlayback() {
    if (!this.grooveSVG) return;

    this.debug('Starting groove playback...');

    const audio = this.getPlaybackAudio();
    if (!audio) {
      this.debug('Failed to decode audio from groove');
      return;
    }

    const { samples: audioData, sampleRate: sr } = audio;
    const speed = parseFloat(document.getElementById('speedSlider').value);
    this.debug(`Speed: ${speed}x | Audio: ${audioData.length} samples at ${sr}Hz = ${(audioData.length / sr).toFixed(2)}s`);

    this.isPlaying = true;
    document.getElementById('playBtn').style.display = 'none';
    document.getElementById('pauseBtn').style.display = 'inline-block';
    document.getElementById('pauseBtn').disabled = false;

    this.playReconstructedAudio(audioData, sr, speed);
    this.animateStylus(speed, audioData.length, sr);
  }

  resampleForPlayback(samples, fromRate, toRate) {
    if (fromRate === toRate) return samples;
    const ratio = fromRate / toRate;
    const newLen = Math.round(samples.length / ratio);
    const out = new Float32Array(newLen);
    const len = samples.length;
    for (let i = 0; i < newLen; i++) {
      const srcPos = i * ratio;
      const idx = Math.floor(srcPos);
      const frac = srcPos - idx;
      const i0 = Math.max(0, idx - 1);
      const i1 = idx;
      const i2 = Math.min(len - 1, idx + 1);
      const i3 = Math.min(len - 1, idx + 2);
      out[i] = cubicInterpolate(samples[i0], samples[i1], samples[i2], samples[i3], frac);
    }
    return out;
  }

  playReconstructedAudio(audioData, sampleRate, speed) {
    try {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const minRate = 8000;
      let playbackData = audioData;
      let playbackRate = sampleRate;

      if (sampleRate < minRate) {
        this.debug(`Upsampling from ${sampleRate}Hz to ${minRate}Hz for playback`);
        playbackData = this.resampleForPlayback(audioData, sampleRate, minRate);
        playbackRate = minRate;
      }

      const buffer = audioContext.createBuffer(1, playbackData.length, playbackRate);
      buffer.copyToChannel(playbackData, 0);

      this.audioSource = audioContext.createBufferSource();
      this.audioSource.buffer = buffer;
      this.audioSource.playbackRate.value = speed;
      this.audioSource.connect(audioContext.destination);
      this.audioSource.start();
      this.audioSource.onended = () => this.stopPlayback();

      const expectedDuration = (audioData.length / sampleRate) / speed;
      this.debug(`Audio playback: ${speed}x rate, ${expectedDuration.toFixed(2)}s expected duration`);
    } catch (error) {
      this.debug(`Audio playback error: ${error.message}`);
    }
  }

  animateStylus(speed, audioLength, sampleRate) {
    const actualAudioDuration = audioLength / sampleRate;
    const playbackDuration = actualAudioDuration / speed;
    const spinSpeed = TAU * 0.5;
    let startTime = performance.now();

    const animate = (currentTime) => {
      if (!this.isPlaying) return;

      const elapsed = (currentTime - startTime) / 1000;
      const progress = Math.min(elapsed / playbackDuration, 1);

      this.discRotation = elapsed * spinSpeed;
      this.stylusProgress = progress;
      this.drawDiscWithGroove(this.discRotation, progress);

      const audioTimePosition = elapsed * speed;
      document.getElementById('currentTime').textContent = this.formatTime(audioTimePosition);

      if (progress < 1) {
        this.animationId = requestAnimationFrame(animate);
      } else {
        this.stopPlayback();
      }
    };

    this.animationId = requestAnimationFrame(animate);
  }

  stopPlayback() {
    this.isPlaying = false;

    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }

    if (this.audioSource) {
      try { this.audioSource.stop(); } catch (e) {}
      this.audioSource = null;
    }

    document.getElementById('playBtn').style.display = 'inline-block';
    document.getElementById('pauseBtn').style.display = 'none';
    document.getElementById('currentTime').textContent = '00:00';

    this.discRotation = 0;
    this.stylusProgress = -1;
    if (this.groovePoints) {
      this.drawDiscWithGroove(0, -1);
    }

    this.debug('Playback stopped');
  }

  downloadSVG() {
    if (!this.grooveSVG) return;

    const blob = new Blob([this.grooveSVG], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'visual_audio_groove.svg';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    this.debug('Visual groove SVG downloaded');
  }

  downloadAudio() {
    const audio = this.getPlaybackAudio();
    if (!audio) return;

    let { samples, sampleRate } = audio;
    const minRate = 8000;
    if (sampleRate < minRate) {
      samples = this.resampleForPlayback(samples, sampleRate, minRate);
      sampleRate = minRate;
    }

    const blob = this.createWAVBlob(samples, sampleRate);
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'reconstructed_audio.wav';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    this.debug('Reconstructed audio downloaded');
  }

  createWAVBlob(audioData, sampleRate) {
    const length = audioData.length;
    sampleRate = sampleRate || this.sampleRate;
    const buffer = new ArrayBuffer(44 + length * 2);
    const view = new DataView(buffer);

    const writeString = (offset, string) => {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    };

    writeString(0, 'RIFF');
    view.setUint32(4, 36 + length * 2, true);
    writeString(8, 'WAVE');
    writeString(12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, 1, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * 2, true);
    view.setUint16(32, 2, true);
    view.setUint16(34, 16, true);
    writeString(36, 'data');
    view.setUint32(40, length * 2, true);

    for (let i = 0; i < length; i++) {
      const sample = Math.max(-1, Math.min(1, audioData[i]));
      view.setInt16(44 + i * 2, sample * 0x7FFF, true);
    }

    return new Blob([buffer], { type: 'audio/wav' });
  }

  updateAudioInfo(file, audioBuffer) {
    document.getElementById('audioInfo').style.display = 'grid';
    document.getElementById('infoDuration').textContent = `${Math.floor(audioBuffer.duration / 60)}:${Math.floor(audioBuffer.duration % 60).toString().padStart(2, '0')}`;
    document.getElementById('infoSampleRate').textContent = `${audioBuffer.sampleRate} Hz`;
    document.getElementById('infoChannels').textContent = audioBuffer.numberOfChannels;
    document.getElementById('infoSize').textContent = `${(file.size / 1024 / 1024).toFixed(1)} MB`;
  }

  updateGrooveInfo(file, result) {
    document.getElementById('audioInfo').style.display = 'grid';
    document.getElementById('infoDuration').textContent = `${Math.floor(this.duration / 60)}:${Math.floor(this.duration % 60).toString().padStart(2, '0')}`;
    document.getElementById('infoSampleRate').textContent = `${result.sampleRate} Hz`;
    document.getElementById('infoChannels').textContent = 'Mono (Visual)';
    document.getElementById('infoSize').textContent = `${(file.size / 1024).toFixed(1)} KB`;
  }

  setStatus(message, type = 'info') {
    const status = document.getElementById('audioStatus');
    status.textContent = message;
    status.className = `status ${type}`;
  }

  formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60).toString().padStart(2, '0');
    return `${mins}:${secs}`;
  }

  debug(message) {
    const timestamp = new Date().toLocaleTimeString();
    const log = document.getElementById('debugLog');
    log.innerHTML += `<br>[${timestamp}] ${message}`;
    log.scrollTop = log.scrollHeight;
    console.log(`[${timestamp}] ${message}`);
  }
}

window.addEventListener('load', () => {
  new GrooveCodec();
});
</script>

<script type="module">
import { connect, disconnect, isConnected, getLocalStorage } from 'https://esm.sh/@stacks/connect@8.2.4';

const btn = document.getElementById('walletBtn');

function truncate(addr) {
  return addr ? addr.slice(0, 6) + '...' + addr.slice(-4) : '';
}

function updateWalletUI() {
  if (isConnected()) {
    const data = getLocalStorage();
    const addrs = data?.addresses?.stx || [];
    const addr = addrs.length > 0 ? addrs[0].address : '';
    btn.innerHTML = `
      Connected
      <span class="wallet-address">${truncate(addr)}</span>
    `;
    btn.classList.add('connected');
    btn.title = addr;
  } else {
    btn.textContent = 'Connect Wallet';
    btn.classList.remove('connected');
    btn.title = '';
  }
}

btn.addEventListener('click', async () => {
  if (isConnected()) {
    disconnect();
    updateWalletUI();
  } else {
    await connect();
    updateWalletUI();
  }
});

updateWalletUI();
</script>
</body>
</html>
